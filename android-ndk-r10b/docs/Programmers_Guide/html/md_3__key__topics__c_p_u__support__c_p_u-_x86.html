<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NDK Programmer&#39;s Guide: x86</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NDK Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_3__key__topics__c_p_u__support__c_p_u-_x86.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">x86 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>Android NDK r6 added support for the '<code>x86</code>' ABI, that allows native code to run on Android-based devices running on CPUs supporting the IA-32 instruction set.</p>
<p>The Android x86 ABI itself is fully specified in docs/CPU-ARCH-ABIS.html.</p>
<h2>Overview</h2>
<p>Generating x86 machine code is simple: just add 'x86' to your APP_ABI definition in your Application.mk file, for example: </p>
<pre class="fragment">    APP_ABI := armeabi armeabi-v7a x86
</pre><p>Alternatively, since NDK r7, you can use: </p>
<pre class="fragment">    APP_ABI := all
</pre><p>will generate machine code for all supported ABIs with this NDK. Doing so will ensure that your application package contains libraries for all target ABIs. Note that this has an impact on package size, since each ABI will correspond to its own set of native libraries built from the same sources.</p>
<p>The default ABI is still '<code>armeabi</code>', if unspecified in your project.</p>
<p>As you would expect, generated libraries will go into <code>$PROJECT/libs/x86/</code>, and will be embedded into your .apk under <code>/lib/x86/</code>.</p>
<p>And just like other ABIs, the Android package manager will extract these libraries on a <em>compatible</em> x86-based device automatically at install time, to put them under &lt;dataPath&gt;/lib, where &lt;dataPath&gt; is the application's private data directory.</p>
<p>Similarly, the Google Play server is capable of filtering applications based on the native libraries they embed and your device's target CPU.</p>
<p>Debugging with ndk-gdb should work exactly as described under docs/NDK-GDB.html.</p>
<h2>ARM NEON intrinsics support</h2>
<p>The solution is shaped as C/C++ language header with the same name as standard arm neon intrinsics header "arm_neon.h" which is also available in all NDK x86 toolchains. It translates neon intrinsics to native x86 SSE ones.</p>
<p>By default SSE up to SSE3 is used for porting ARM NEON to Intel SSE.</p>
<p>Current solution covers by default ~41% NEON functions (889 of total 1884) and 47% when -mssse3 is enabled. It is highly recommended to use the -mssse3 compiler flag for more coverage and performance.</p>
<p>If currently provided coverage is not enough to port application please look into next version preview (up to 98% NEON instrinsics covered) <a href="http://software.intel.com/en-us/blogs/2012/12/12/from-arm-neon-to-intel-mmxsse-automatic-porting-solution-tips-and-tricks">here</a></p>
<p>The solution</p>
<ul>
<li>Redefines ARM NEON 128 bit vectors as the corresponding x86 SIMD data.</li>
<li>Redefines some functions from ARM NEON to Intel SSE if 1:1 correspondence exists.</li>
<li>Implements some ARM NEON functions using Intel SIMD if the performance effective implementation is possible.</li>
<li>Implements some of the remaining NEON functions using the serial solution and issuing the corresponding "low performance" compiler warning.</li>
</ul>
<h3>Performance:</h3>
<p>For the major number of cases it is expected to obtain the similar to ARM NEON native perfomance gain for vectorized vs. serial code.</p>
<h3>Porting considerations and best known methods are:</h3>
<ul>
<li>Use 16-byte data alignment for faster load and store</li>
<li>Avoid NEON functions working with constants. It produces performance penalty for constants load. If constants usage is necessary try to move constants initialization out of hotspot loops and if applicable replace it with logical and compare operations.</li>
<li>Try to avoid functions marked as "serialy implemented" because they need to store data from registers to memory, process them serialy and load them again. Probably you could change the data type or algorithm used to make the whole port vectorized not a serial one.</li>
</ul>
<p>To learn more about it, see <a href="http://software.intel.com/en-us/blogs/2012/12/12/from-arm-neon-to-intel-mmxsse-automatic-porting-solution-tips-and-tricks">here</a>.</p>
<h3>Sample code:</h3>
<p>In your project add 'x86' to APP_ABI definition and make sure "arm_neon.h" header is included. Your code will be ported to x86 without any other changes necessary.</p>
<h2>Standalone-toolchain</h2>
<p>It is possible to use the x86 toolchain with NDK r6 in stand-alone mode. See docs/STANDALONE-TOOLCHAIN.html for more details. Briefly speaking, it is now possible to run: </p>
<pre class="fragment">  $NDK/build/tools/make-standalone-toolchain.sh --arch=x86 --install-dir=&lt;path&gt;
</pre><p>The toolchain binaries have the <code>i686-linux-android- prefix</code>.</p>
<h2>Compatibility</h2>
<p>The minimal native API level provided by official Android x86 platform builds is 9, which corresponds to all the native APIs provided by Android 2.3, i.e. Gingerbread (note also that no new native APIs were introduced by Honeycomb).</p>
<p>You won't have to change anything to your project files if you target an older API level: the NDK build script will automatically select the right set of native platform headers/libraries for you. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 25 2014 00:51:19 for NDK Programmer&#39;s Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
